'use strict';
/**
 * Update Anchor Peers after join channel
 * Author: Cathy
 */
var logger = require('log4js').getLogger('Update-Anchor-Peers');
const utils = require('fabric-client/lib/utils.js');
var util = require('util');
const Fabric_Client = require('fabric-client');
const fs = require('fs');
const path = require('path');
logger.level = 'DEBUG';

const ProtoLoader = require('fabric-client/lib/ProtoLoader');

//const _commonProto = ProtoLoader.load(path.resolve(__dirname, '../../../fabric-client/lib/protos/common/common.proto')).common;
//const anchorPeerTXFile = path.join(__dirname, '../../fixtures/crypto-material/channel-config/mychannel-org1anchor.tx');

/**
 * 
 * @param {*} channelName 
 * @param {*} peerURL 
 * @param {*} orderURL 
 * @param {string} anchorPeerTxFile file path. Anchor peer file can be generated by `configtxgen` with `outputAnchorPeersUpdate` option
 * @param {*} adminUser 
 * @param {*} mspID 
 * @param {*} adminCerts 
 * @param {*} peerTlsPemFile 
 * @param {*} orderTlsPemFile 
 */
var updateAnchorPeers = function (channelName, peerURL, orderURL, anchorPeerTxFile, adminUser, mspID,
	adminCerts, peerTlsPemFile, orderTlsPemFile) {
	logger.info('============ Update Anchor Peers for Channel ' + channelName + ' ============');

	var client = new Fabric_Client();
	var channel = client.newChannel(channelName);
	// TLS
	var opt;
	if (peerTlsPemFile) {
		let data = fs.readFileSync(path.join(Fabric_Client.getConfigSetting('keyValueStore'), peerTlsPemFile));
		opt = {
			pem: Buffer.from(data).toString()
		};
	}
	var peer = client.newPeer(peerURL, opt);
	channel.addPeer(peer, mspID);

	opt = null;
	if (orderTlsPemFile) {
		let dataPem = fs.readFileSync(path.join(Fabric_Client.getConfigSetting('keyValueStore'), orderTlsPemFile));
		opt = {
			pem: Buffer.from(dataPem).toString()
		};
	}
	var orderer = client.newOrderer(orderURL, opt)
	channel.addOrderer(orderer);
	

	var member_user = null;
	var tx_id = null;
	var store_path = Fabric_Client.getConfigSetting('keyValueStore');
	logger.info('Store path:' + store_path);

	return new Promise((resolve, reject) => {
		// Get Org Admin first
		var keyPath = path.join(__dirname, Fabric_Client.getConfigSetting('adminPath'), adminCerts.key);
		let keyData = fs.readFileSync(keyPath);
		var keyPEM = Buffer.from(keyData).toString();
		var certPath = path.join(__dirname, Fabric_Client.getConfigSetting('adminPath'), adminCerts.cert);
		let certData = fs.readFileSync(certPath);
		var certPEM = certData.toString();

		var cryptoSuite = Fabric_Client.newCryptoSuite();
		cryptoSuite.setCryptoKeyStore(Fabric_Client.newCryptoKeyStore({
			path: store_path
		}));
		client.setCryptoSuite(cryptoSuite);

		Fabric_Client.newDefaultKeyValueStore({
			path: store_path
		}).then((state_store) => {
			// assign the store to the fabric client
			client.setStateStore(state_store);

			return client.createUser({
				username: adminUser,
				mspid: mspID,
				cryptoContent: {
					privateKeyPEM: keyPEM,
					signedCertPEM: certPEM
				}
			});
		}).then((user_from_store) => {
			if (user_from_store && user_from_store.isEnrolled()) {
				logger.info('Successfully loaded ' + adminUser + ' from persistence');
				member_user = user_from_store;
			} else {
				throw new Error('Failed to get ' + adminUser + '.... run registerUser.js');
			}

			return channel.initialize();
		}).then(() => {
			const eventHub = channel.newChannelEventHub(peer);
	 		eventHub.connect(true);
			const blockEventPromise = new Promise((resolve, reject) => {
				const block_registration_number = eventHub.registerBlockEvent((block) => {
					if (block.data.data.length !== 1) {
						logger.error('Config block must only contain one transaction');
						return;
					}
					const envelope = block.data.data[0];
					const channel_header = envelope.payload.header.channel_header;
					logger.info(JSON.stringify(channel_header));
		
					if (channel_header.type !== HeaderType.CONFIG) {
						logger.error(`expect block of type "CONFIG" (${HeaderType.CONFIG}), but got "${channel_header.type}" instead`);
						return;
					}
		
					logger.info('Successfully update anchor peers.');
					eventHub.unregisterBlockEvent(block_registration_number, true);
					eventHub.disconnect();
					resolve(block);
				}, (err) => {
					logger.error(`err caught in blockEvent: after update anchor peers, ${err}`);
					eventHub.unregisterBlockEvent(block_registration_number, true);
					eventHub.disconnect();
					reject(err);
				});
		
			});
			const client = channel._clientContext;
			const channelConfig_envelop = fs.readFileSync(path.join(__dirname, anchorPeerTxFile));
			const channelConfig = client.extractChannelConfig(channelConfig_envelop);
			const signature = client.signChannelConfig(channelConfig);
			tx_id = client.newTransactionID();
			const request = {
				config: channelConfig,
				signatures: [signature],
				name: channel.getName(),
				orderer,
				txId: tx_id
			};
			var updateChannelPromise = client.updateChannel(request);

			return Promise.all([updateChannelPromise, blockEventPromise]);
			
		}, (err)=>{
			let errMsg = 'Failed to initialize channel: ' + err.stack ? err.stack : err;
			logger.error(errMsg);
			throw new Error(errMsg);
		}).then((results) => {
			logger.info(results);
			logger.info('Update Channel promise and block event listener promise have completed');
			resolve();
		}, (err)=>{
			reject(err);
		}).catch((err) => {
			let errMsg = 'Failed to update anchor peers: ' + err;
			logger.error(errMsg);
			reject(errMsg);
		});
	}).catch((err) => {
		let errMsg = 'Failed to update anchor peers: ' + err;
		logger.error(errMsg);
		reject(errMsg);
	});

};

var HeaderType = {
    // Prevent removed tag re-use
    // Uncomment after fabric-baseimage moves to 3.5.1
    // reserved 7;
    // reserved "PEER_RESOURCE_UPDATE";

    MESSAGE: 0,                   // Used for messages which are signed but opaque
    CONFIG: 1,                    // Used for messages which express the channel config
    CONFIG_UPDATE: 2,             // Used for transactions which update the channel config
    ENDORSER_TRANSACTION: 3,      // Used by the SDK to submit endorser based transactions
    ORDERER_TRANSACTION: 4,       // Used internally by the orderer for management
    DELIVER_SEEK_INFO: 5,         // Used as the type for Envelope messages submitted to instruct the Deliver API to seek
    CHAINCODE_PACKAGE: 6,         // Used for packaging chaincode artifacts for install
    PEER_ADMIN_OPERATION: 8      // Used for invoking an administrative operation on a peer
};

exports.updateAnchorPeers = updateAnchorPeers;